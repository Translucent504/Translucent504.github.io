---
title: "[TIL] 27-Feb-2020"
excerpt_separator: "<!--more-->"
categories:
  - today-i-learned
tags:
  - til 
---

> Python Bit Manipulation

<!--more-->

**Counting Number of set bits** can be done by either using the naive approach of simply bit shifting to the right by 1 and checking if the last bit is 1 or 0 or by using Peter Wegner's method of removing the lowest set bit on each loop iteration by using subtraction. The naive approach will have the number of iterations equal to the bit of the highest set bit in the integer like a 32 bit int with only the 32 bit = 1 will take 32 loop iterations, while the wegner's method has iterations equal to the number of set bits, it will take only 1 iteration for the 32 bit int with only the 32nd bit = 1.

```python
def count_bits(x: int) -> int:
    """Naive Method"""
    num_bits = 0
    while x:
        num_bits += x & 1
        x >>= 1
    return num_bits


def count_bits(x: int) -> int:
    """Wegner's Method"""
    num_bits = 0
    while x:
        num_bits += 1
        x &= x - 1
    return num_bits
```

Another key bit-fiddling trick isolates the lowest bit that is 1 in x here `~` is the bitwise complement operator. 

```
x & ~(x-1)
```

**Variant**: Write expressions that use bitwise operators, equality checks, and Boolean operators to do the following in O(1) time:
  - Right propagate the rightmost set bit in x, e.g., turns $$(01010000)_2$$ to $$(01011111)_2$$.
    - x \| (x - 1)
  - Compute $$x\ mod\ n$$ where n is a power of 2. e.g. returns 13 for 77 mod 64.
    -  x & (n - 1)
  - Test if $$x$$ is a power of 2 ,i.e.evaluates to true for x = 1, 2, 4, 8... False for all other values.
    - not bool(x & (x - 1)) _solution 1_
    - x == (x & ~(x - 1)) _solution 2_
